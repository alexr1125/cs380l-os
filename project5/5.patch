diff -ruN src/defs.h src-finished/defs.h
--- src/defs.h	2022-05-08 06:15:25.478748153 +0000
+++ src-finished/defs.h	2022-05-08 06:13:43.901873021 +0000
@@ -33,7 +33,7 @@
 int             fileread(struct file*, char*, int n);
 int             filestat(struct file*, struct stat*);
 int             filewrite(struct file*, char*, int n);
-
+int             fileseek(struct file* f, uint offset);
 // fs.c
 void            readsb(int dev, struct superblock *sb);
 int             dirlink(struct inode*, char*, uint);
@@ -69,6 +69,10 @@
 void            kinit1(void*, void*);
 void            kinit2(void*, void*);
 
+// kmalloc.c
+void*           kmalloc(uint);
+void            kmfree(void*);
+
 // kbd.c
 void            kbdintr(void);
 
@@ -120,6 +124,9 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void*           mmap(void*, uint, int, int, int, int);
+int             munmap(void*, uint);
+int             msync(void *, int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -175,7 +182,8 @@
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
-int             allocuvm(pde_t*, uint, uint);
+int             allocuvm_mmap(pde_t*, uint, uint);
+int             allocuvm_proc(pde_t*, uint, uint);
 int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
@@ -185,6 +193,6 @@
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
-
+int             mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff -ruN src/exec.c src-finished/exec.c
--- src/exec.c	2022-05-08 06:15:25.482748329 +0000
+++ src-finished/exec.c	2022-05-08 06:13:43.901873021 +0000
@@ -49,7 +49,7 @@
       goto bad;
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+    if((sz = allocuvm_proc(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
     if(ph.vaddr % PGSIZE != 0)
       goto bad;
@@ -63,7 +63,7 @@
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  if((sz = allocuvm_proc(pgdir, sz, sz + 2*PGSIZE)) == 0)
     goto bad;
   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
   sp = sz;
diff -ruN src/file.c src-finished/file.c
--- src/file.c	2022-05-08 06:15:25.502749206 +0000
+++ src-finished/file.c	2022-05-08 06:13:43.901873021 +0000
@@ -155,3 +155,12 @@
   panic("filewrite");
 }
 
+int fileseek(struct file* f, uint offset) {
+  if(f->type == FD_INODE){
+    ilock(f->ip);
+    f->off = offset;
+    iunlock(f->ip);
+    return 0;
+  }
+  return -1;
+}
\ No newline at end of file
diff -ruN src/kmalloc.c src-finished/kmalloc.c
--- src/kmalloc.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/kmalloc.c	2022-05-08 06:13:43.901873021 +0000
@@ -0,0 +1,94 @@
+#include "types.h"
+#include "defs.h"
+#include "mmu.h"
+
+// Memory allocator by Kernighan and Ritchie,
+// The C programming Language, 2nd ed.  Section 8.7.
+// Modified for allocation in the kernel.
+
+typedef long Align;
+
+union header {
+  struct {
+    union header *ptr;
+    uint size;
+  } s;
+  Align x;
+};
+
+typedef union header Header;
+
+static Header base;
+static Header *freep;
+
+void
+kmfree(void *addr)
+{
+  Header *bp, *p;
+
+  bp = (Header*)addr - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+  freep = p;
+}
+
+static Header*
+morecore(uint nu)
+{
+  char *p;
+  Header *hp;
+
+  if (nu * sizeof(Header) > PGSIZE) {
+    panic("kmalloc: memory allocation too big");
+  }
+  if (PGSIZE % sizeof(Header) != 0) {
+    panic("kmalloc: memory allocation not (header) aligned");
+  }
+  if ((p = kalloc()) == (char*)0) {
+    panic("kmalloc: memory allocation failed");
+  }
+  hp = (Header*)p;
+  hp->s.size = PGSIZE / sizeof(Header);
+  kmfree((void*)(hp + 1));
+  return freep;
+}
+
+void*
+kmalloc(uint nbytes)
+{
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+      if(p->s.size == nunits)
+        prevp->s.ptr = p->s.ptr;
+      else {
+        p->s.size -= nunits;
+        p += p->s.size;
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+}
diff -ruN src/Makefile src-finished/Makefile
--- src/Makefile	2022-05-08 06:16:39.905812389 +0000
+++ src-finished/Makefile	2022-05-08 06:13:43.901873021 +0000
@@ -7,6 +7,7 @@
 	ide.o\
 	ioapic.o\
 	kalloc.o\
+	kmalloc.o\
 	kbd.o\
 	lapic.o\
 	log.o\
@@ -21,6 +22,7 @@
 	swtch.o\
 	syscall.o\
 	sysfile.o\
+	sysmalloc.o\
 	sysproc.o\
 	trapasm.o\
 	trap.o\
diff -ruN src/Makefile.test src-finished/Makefile.test
--- src/Makefile.test	2022-05-08 06:15:25.478748153 +0000
+++ src-finished/Makefile.test	2022-05-08 06:13:43.901873021 +0000
@@ -7,6 +7,7 @@
 	ide.o\
 	ioapic.o\
 	kalloc.o\
+	kmalloc.o\
 	kbd.o\
 	lapic.o\
 	log.o\
@@ -21,6 +22,7 @@
 	swtch.o\
 	syscall.o\
 	sysfile.o\
+	sysmalloc.o\
 	sysproc.o\
 	trapasm.o\
 	trap.o\
@@ -181,7 +183,6 @@
 	_test_5\
 	_test_6\
 	_test_7\
-	_test_8\
 	_mkdir\
 	_rm\
 	_sh\
@@ -190,8 +191,8 @@
 	_wc\
 	_zombie\
 
-fs.img: mkfs README $(UPROGS)
-	./mkfs fs.img README $(UPROGS)
+fs.img: mkfs README sample.txt $(UPROGS)
+	./mkfs fs.img README sample.txt $(UPROGS)
 
 -include *.d
 
@@ -204,7 +205,7 @@
 
 # make a printout
 FILES = $(shell grep -v '^\#' runoff.list)
-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+PRINT = runoff.list runoff.spec README sample.txt toc.hdr toc.ftr $(FILES)
 
 xv6.pdf: $(PRINT)
 	./runoff
@@ -259,7 +260,7 @@
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	README sample.txt dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
 dist:
diff -ruN src/memlayout.h src-finished/memlayout.h
--- src/memlayout.h	2022-05-08 06:15:25.490748680 +0000
+++ src-finished/memlayout.h	2022-05-08 06:13:43.901873021 +0000
@@ -13,3 +13,5 @@
 
 #define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
 #define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+
+#define MMAPBASE 0x40000000
diff -ruN src/mman.h src-finished/mman.h
--- src/mman.h	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/mman.h	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,11 @@
+#ifndef _MMAN_H_
+#define _MMAN_H_
+
+/* Protection bits */
+#define PROT_WRITE    1
+
+/* Flags */
+#define MAP_ANONYMOUS 0
+#define MAP_FILE      1
+
+#endif /* _MMAN_H_ */
\ No newline at end of file
diff -ruN src/mmu.h src-finished/mmu.h
--- src/mmu.h	2022-05-08 06:15:25.490748680 +0000
+++ src-finished/mmu.h	2022-05-08 06:13:43.901873021 +0000
@@ -94,6 +94,7 @@
 #define PTE_P           0x001   // Present
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
+#define PTE_D           0x006   // Dirty
 #define PTE_PS          0x080   // Page Size
 
 // Address in page table or page directory entry
diff -ruN src/proc.c src-finished/proc.c
--- src/proc.c	2022-05-08 06:15:25.498749031 +0000
+++ src-finished/proc.c	2022-05-08 06:13:43.901873021 +0000
@@ -6,6 +6,12 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "mman.h"
+#include "file.h"
+
+extern pte_t *walkpgdir(pde_t *pgdir, const void *va, int alloc);
 
 struct {
   struct spinlock lock;
@@ -20,6 +26,8 @@
 
 static void wakeup1(void *chan);
 
+static void free_mmap_regions(struct mmap_region *mmap_regions);
+
 void
 pinit(void)
 {
@@ -142,6 +150,8 @@
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
+  p->mmap_regions = (struct mmap_region*)0;
+
   // this assignment to p->state lets other cores
   // run this process. the acquire forces the above
   // writes to be visible, and the lock is also needed
@@ -163,7 +173,7 @@
 
   sz = curproc->sz;
   if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+    if((sz = allocuvm_proc(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   } else if(n < 0){
     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
@@ -183,14 +193,44 @@
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
+  struct mmap_region *mmap, *new_mmap, *prev_mmap;
 
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
   }
 
+  // Copy the mmap regions.
+  for(mmap = curproc->mmap_regions, prev_mmap = (struct mmap_region*)0;
+      mmap != (struct mmap_region*)0;
+      mmap = mmap->next_mmap_region, prev_mmap = new_mmap){
+    if((new_mmap = kmalloc(sizeof(struct mmap_region))) ==
+       (struct mmap_region*)0){
+      free_mmap_regions(np->mmap_regions);
+      np->mmap_regions = (struct mmap_region*)0;
+      kfree(np->kstack);
+      np->kstack = 0;
+      np->state = UNUSED;
+      return -1;
+    }
+    new_mmap->start_addr = mmap->start_addr;
+    new_mmap->length = mmap->length;
+    new_mmap->prot = mmap->prot;
+    new_mmap->flags = mmap->flags;
+    new_mmap->fd = mmap->fd;
+    new_mmap->offset = mmap->offset;
+    new_mmap->next_mmap_region = (struct mmap_region*)0;
+    if(prev_mmap != (struct mmap_region*)0){
+      prev_mmap->next_mmap_region = new_mmap;
+    } else{
+      np->mmap_regions = new_mmap;
+    }
+  }
+
   // Copy process state from proc.
   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+    free_mmap_regions(np->mmap_regions);
+    np->mmap_regions = (struct mmap_region*)0;
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -295,6 +335,8 @@
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        free_mmap_regions(p->mmap_regions);
+        p->mmap_regions = (struct mmap_region*)0;
         release(&ptable.lock);
         return pid;
       }
@@ -496,6 +538,136 @@
   return -1;
 }
 
+void*
+mmap(void* addr, uint length, int prot, int flags, int fd, int offset)
+{
+  struct mmap_region *mmap;
+  struct proc *curproc = myproc();
+  int bad_addr;
+
+  addr = (void*)PGROUNDUP((uint)addr + MMAPBASE);
+  if ((uint)addr >= KERNBASE ||
+      (uint)addr + PGROUNDUP(length) >= KERNBASE) {
+    addr = (void*)MMAPBASE;
+    if ((uint)addr + PGROUNDUP(length) >= KERNBASE) {
+      return (void*)0;
+    }
+  }
+  for (mmap = curproc->mmap_regions; mmap != (struct mmap_region*)0
+         ;) {
+    bad_addr = 0;
+    if ((uint)addr >= (uint)mmap->start_addr &&
+        (uint)mmap->start_addr + PGROUNDUP(mmap->length) >= (uint)addr) { 
+      bad_addr = 1;
+    }
+    if ((uint)mmap->start_addr >= (uint)addr &&
+        (uint)addr + PGROUNDUP(length) >= (uint)mmap->start_addr) {
+      bad_addr = 1;
+    }
+    if (bad_addr) {
+      addr = (void*)(mmap->start_addr + PGROUNDUP(mmap->length) + PGSIZE);
+      mmap = curproc->mmap_regions;
+      continue;
+    }
+    mmap = mmap->next_mmap_region;
+  }
+  if ((uint)addr >= KERNBASE ||
+      (uint)addr + PGROUNDUP(length) >= KERNBASE) {
+    return (void*)0;
+  }
+
+  /* Comment this out to implement lazy page allocation */
+  // if (allocuvm_mmap(curproc->pgdir, (uint)addr, (uint)addr + length) == 0) {
+  //   return (void*)0;
+  // }
+  if ((mmap = kmalloc(sizeof(struct mmap_region))) ==
+      (struct mmap_region*)0) {
+    /* No longer need to dealloc in case of an error since we are no longer allocating the physical memory here */
+    // deallocuvm(curproc->pgdir, (uint)addr + length, (uint)addr);
+    return (void*)0;
+  }
+
+  /* Error check the fd */
+  if (flags == MAP_FILE) {
+    if((fd < 0 || fd >= NOFILE) ||
+       (curproc->ofile[fd] == 0))
+    {
+      kfree((char *) mmap);
+      return (void *) -1;
+    }
+
+    struct file *file = curproc->ofile[fd];
+    if (file->readable == 0 || file->writable == 0)
+    {
+      kfree( (char *) mmap);
+      return (void *) -1;
+    }
+    
+    mmap->fd = (int) filedup(file);
+    fileseek((struct file *) mmap->fd, offset);
+  }  else {
+    mmap->fd = -1;
+  }
+
+  mmap->start_addr = (uint)addr;
+  mmap->length = length;
+  mmap->prot = (prot == PROT_WRITE) ? PTE_W : 0;
+  mmap->flags = flags;
+  mmap->offset = offset;
+  mmap->next_mmap_region = curproc->mmap_regions;
+  curproc->mmap_regions = mmap;
+  return addr;
+}
+
+int
+munmap(void *addr, uint length)
+{
+  struct mmap_region *mmap, *prev_mmap;
+  struct proc *curproc = myproc();
+
+  for (mmap = curproc->mmap_regions, prev_mmap = (struct mmap_region*)0;
+       mmap != (struct mmap_region*)0;
+       prev_mmap = mmap, mmap = mmap->next_mmap_region) {
+    if ((uint)addr == (uint)mmap->start_addr && length == mmap->length) {
+      deallocuvm(curproc->pgdir, (uint)addr + length, (uint)addr);
+      if (prev_mmap != (struct mmap_region*)0) {
+        prev_mmap->next_mmap_region = mmap->next_mmap_region;
+      } else {
+        curproc->mmap_regions = mmap->next_mmap_region;
+      }
+      
+      /* Close the fd */
+      if (mmap->flags == MAP_FILE) {
+        fileclose((struct file *) mmap->fd);
+      }
+      kmfree(mmap);
+      return 0;
+    }
+  }
+  return -1;
+}
+
+static void
+free_mmap_regions(struct mmap_region *mmap_regions)
+{
+  struct mmap_region *mmap;
+
+  for(mmap = mmap_regions; mmap != (struct mmap_region*)0;
+      mmap = mmap->next_mmap_region){
+    mmap->start_addr = 0;
+    mmap->length = 0;
+    mmap->prot = 0;
+    mmap->flags = 0;
+    mmap->fd = 0;
+    mmap->offset = 0;
+  }
+  while(mmap_regions != (struct mmap_region*)0){
+    mmap = mmap_regions;
+    mmap_regions = mmap->next_mmap_region;
+    kmfree(mmap);
+  }
+}
+
 //PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
@@ -532,3 +704,47 @@
     cprintf("\n");
   }
 }
+
+int msync(void* start_addr, int length) {
+  struct proc *curproc = myproc();
+  /* find the corresponding region in the mmap linked list */
+  struct mmap_region *curr_region = curproc->mmap_regions;
+  while (curr_region != (struct mmap_region *) 0) {
+    /* Check the range of the region */
+    if ((uint) start_addr == curr_region->start_addr) {
+      // cprintf("XV6_TEST_OUTPUT : found mmap region\n");
+      break;
+    }
+
+    curr_region = curr_region->next_mmap_region;
+  }
+
+  if (curr_region == (struct mmap_region *) 0) {
+    return -1;
+  }
+
+  if (curr_region->length != length) {
+    return -1;
+  }
+  /*
+    Go through the entire region page by page.
+    For each page check if it has been allocated (walkpgdir).
+    If it has, check the dirty bit. If set, then write to file.
+    Else do nothing.
+  */
+  void *curr_address = start_addr;
+  struct file *file = (struct file *)curr_region->fd;
+  int curr_offset = curr_region->offset;
+  pte_t *pte;
+  while ((int) curr_address < (int) start_addr + length) {
+    fileseek(file, curr_offset);
+    pte = walkpgdir(curproc->pgdir, curr_address, 0);
+    if ((pte != (pte_t *) 0) && ((*pte & (1 << PTE_D)) != 0)) {
+      filewrite(file, curr_address, PGSIZE);
+    }
+    curr_offset += PGSIZE;
+    curr_address += PGSIZE;
+  }
+
+  return 0;
+}
\ No newline at end of file
diff -ruN src/proc.h src-finished/proc.h
--- src/proc.h	2022-05-08 06:15:25.482748329 +0000
+++ src-finished/proc.h	2022-05-08 06:13:43.901873021 +0000
@@ -34,6 +34,19 @@
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+// Per-process mmap
+struct mmap_region {
+  uint start_addr;             // Starting address (page aligned)
+  uint length;                 // Size of mmap
+  int prot;                    // Memory protections
+  int flags;                   // Region type (anonymous vs. file-backed)
+  int fd;                      // File-backed memory region
+  int offset;                  // Offset into file-backed memory region
+
+  // Next mmap region
+  struct mmap_region *next_mmap_region;
+};
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,6 +62,9 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  // Mmap regions
+  struct mmap_region *mmap_regions;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -ruN src/syscall.c src-finished/syscall.c
--- src/syscall.c	2022-05-08 06:15:25.490748680 +0000
+++ src-finished/syscall.c	2022-05-08 06:13:43.901873021 +0000
@@ -103,6 +103,11 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_kmalloc(void);
+extern int sys_kmfree(void);
+extern int sys_mmap(void);
+extern int sys_munmap(void);
+extern int sys_msync(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,11 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_kmalloc] sys_kmalloc,
+[SYS_kmfree]  sys_kmfree,
+[SYS_mmap]    sys_mmap,
+[SYS_munmap]  sys_munmap,
+[SYS_msync]  sys_msync,
 };
 
 void
diff -ruN src/syscall.h src-finished/syscall.h
--- src/syscall.h	2022-05-08 06:15:25.506749382 +0000
+++ src-finished/syscall.h	2022-05-08 06:13:43.901873021 +0000
@@ -1,22 +1,27 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_fork     1
+#define SYS_exit     2
+#define SYS_wait     3
+#define SYS_pipe     4
+#define SYS_read     5
+#define SYS_kill     6
+#define SYS_exec     7
+#define SYS_fstat    8
+#define SYS_chdir    9
+#define SYS_dup     10
+#define SYS_getpid  11
+#define SYS_sbrk    12
+#define SYS_sleep   13
+#define SYS_uptime  14
+#define SYS_open    15
+#define SYS_write   16
+#define SYS_mknod   17
+#define SYS_unlink  18
+#define SYS_link    19
+#define SYS_mkdir   20
+#define SYS_close   21
+#define SYS_kmalloc 22
+#define SYS_kmfree  23
+#define SYS_mmap    24
+#define SYS_munmap  25
+#define SYS_msync   26
diff -ruN src/sysmalloc.c src-finished/sysmalloc.c
--- src/sysmalloc.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/sysmalloc.c	2022-05-08 06:13:43.901873021 +0000
@@ -0,0 +1,31 @@
+//
+// Kernel memory system calls.
+// This is purely for testing purposes and is a wrapper for
+// calling the kmalloc & kmfree from the user space.
+//
+
+#include "types.h"
+#include "defs.h"
+
+int
+sys_kmalloc(void)
+{
+  int nbytes;
+
+  if (argint(0, &nbytes) < 0) {
+    return -1;
+  }
+  return (int)kmalloc((uint)nbytes);
+}
+
+int
+sys_kmfree(void)
+{
+  void *addr;
+
+  if (argptr(0, (void*)&addr, sizeof(addr)) < 0) {
+    return -1;
+  }
+  kmfree(addr);
+  return 0;
+}
diff -ruN src/sysproc.c src-finished/sysproc.c
--- src/sysproc.c	2022-05-08 06:15:25.478748153 +0000
+++ src-finished/sysproc.c	2022-05-08 06:13:43.901873021 +0000
@@ -6,6 +6,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "mman.h"
 
 int
 sys_fork(void)
@@ -89,3 +90,69 @@
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_mmap(void)
+{
+  int addr, len, prot, flags, fd, offset;
+
+  if (argint(0, &addr) < 0) {
+    return 0;
+  }
+  if (argint(1, &len) < 0) {
+    return 0;
+  }
+  if (argint(2, &prot) < 0) {
+    return 0;
+  }
+  if (argint(3, &flags) < 0) {
+    return 0;
+  }
+  if (argint(4, &fd) < 0) {
+    return 0;
+  }
+  if (argint(5, &offset) < 0) {
+    return 0;
+  }
+
+  if (flags == MAP_ANONYMOUS) {
+    if (fd != -1) {
+      return -1;
+    }
+  } else if (flags == MAP_FILE) {
+    if (fd == -1) {
+      return -1;
+    }
+  } else {
+    return -1;
+  }
+
+  return (int)mmap((void*)addr, (uint)len, prot, flags, fd, offset);
+}
+
+int
+sys_munmap(void)
+{
+  int addr, len;
+
+  if (argint(0, &addr) < 0) {
+    return -1;
+  }
+  if (argint(1, &len) < 0) {
+    return -1;
+  }
+  return munmap((void*)addr, (uint)len);
+}
+
+int sys_msync(void) {
+  int addr, len;
+
+  if (argint(0, &addr) < 0) {
+    return -1;
+  }
+  if (argint(1, &len) < 0) {
+    return -1;
+  }
+
+  return msync((void *) addr, len);
+}
\ No newline at end of file
diff -ruN src/test_1.c src-finished/test_1.c
--- src/test_1.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_1.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,60 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+
+
+/*Testing whether address returned by anonymous mmap is page aligned.*/
+int
+main(int argc, char *argv[])
+{
+  int size = 200;
+  char *r1 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  char *r2 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  char *r3 = mmap(0, size, 0/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  int rem1 = ((int)r1 % PGSIZE);
+  int rem2 = ((int)r2 % PGSIZE);
+  int rem3 = ((int)r3 % PGSIZE);
+
+  printf(1, "XV6_TEST_OUTPUT : rem1 = %d rem2 = %d rem3 = %d\n",rem1,rem2,rem3);
+
+  if(rem1 != 0 || rem2 != 0 || rem3 != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : Address returned by mmap should be page aligned\n");
+    exit();
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : mmap good --> address returned is page aligned\n");
+
+  int rv1 = munmap(r1, size);
+  if (rv1 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+
+  int rv2 = munmap(r2, size);
+  if (rv2 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+
+
+  int rv3 = munmap(r3, size);
+  if (rv3 < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  
+  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
+
+  exit();
+}
diff -ruN src/test_2.c src-finished/test_2.c
--- src/test_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_2.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,49 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+/* Testing Anonymous mmap with PROT_WRITE*/
+
+int
+main(int argc, char *argv[])
+{
+  int size =  10;  /* we need 10 bytes */
+ 
+  // mmap
+  char *addr = (char*)0x4000;
+  char* str = mmap(addr, size,  PROT_WRITE/*prot*/, MAP_ANONYMOUS, -1/*fd*/, 0/*offset*/);
+
+  if (str<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
+
+
+  printf(1, "XV6_TEST_OUTPUT : Strlen Before modification: %d\n", strlen((char*)str));
+
+  strcpy(str, "012345");
+
+  printf(1, "XV6_TEST_OUTPUT : str = %s\n", (char*)str);
+  printf(1, "XV6_TEST_OUTPUT : Strlen After modification: %d\n", strlen((char*)str));
+
+
+  // munmap
+  int rv = munmap(str, size);
+  if (rv < 0) {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+
+  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
+  exit();
+}
diff -ruN src/test_3.c src-finished/test_3.c
--- src/test_3.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_3.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,38 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+/* Testing Anonymous mmap without PROT_WRITE*/
+
+int
+main(int argc, char *argv[])
+{  
+  int size =  10;  /* we need 10 bytes */
+ 
+  char *addr = (char*)0x4000;
+  char* str = mmap(addr, size,  0/*prot*/, MAP_ANONYMOUS, -1/*fd*/, 0/*offset*/);
+
+  if (str<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
+
+
+  printf(1, "XV6_TEST_OUTPUT : Strlen Before modification: %d\n", strlen((char*)str));
+
+  strcpy(str, "012345"); //This should fail
+
+  printf(1, "XV6_TEST_OUTPUT : this shouldn't print\n");
+  
+  exit();
+}
diff -ruN src/test_4.c src-finished/test_4.c
--- src/test_4.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_4.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,64 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+ /* Testing Anonymous mmap that spans across multiple pages*/
+int
+main(int argc, char *argv[])
+{
+  int size =  3*PGSIZE;
+
+  // mmap
+  char *addr = (char*)0x4000;
+  char* r = mmap(addr, size,  PROT_WRITE/*prot*/, 0/*flags*/, -1/*fd*/, 0/*offset*/);
+
+  if (r<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  
+  printf(1, "XV6_TEST_OUTPUT : mmap good\n");
+
+
+  // memset and validate
+  memset(r, 'a', size - 1);
+  printf(1, "XV6_TEST_OUTPUT : strlen(r) = %d\n", strlen(r));
+
+  char* aChars = malloc(size);
+  memset(aChars, 'a', size-1);
+
+  int ret = strcmp(r, aChars);
+  printf(1, "XV6_TEST_OUTPUT : Return val of strcmp %d\n", ret);
+
+  free(aChars);
+  if (ret != 0) {
+    printf(1, "XV6_TEST_OUTPUT : value at the newly mapped anonymous memory region is wrong.!!\n");
+    exit();
+  }
+  else
+  {
+    printf(1, "XV6_TEST_OUTPUT : value at the newly mapped anonymous memory region is correct.!!\n");
+  }
+
+
+  // munmap
+  int rv = munmap(r, size);
+  if (rv < 0) 
+  {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : munmap good\n");
+
+  
+  exit();
+}
diff -ruN src/test_5.c src-finished/test_5.c
--- src/test_5.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_5.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,124 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+
+/* File Backed mmap test : Accessing mmap-ed memory region after file close.
+The contents should persist.*/
+
+int
+main(int argc, char *argv[])
+{
+  int rc;
+  char fileName[50];
+  strcpy(fileName, "sample.txt");
+
+
+  // open existing file
+  int fd = open(fileName, O_RDWR);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file open failed %d\n", fd);
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file open suceeded\n");
+
+
+
+  // Read the file content into buff1
+  char buff1[256];
+  int sz = read(fd, buff1, 50);
+  buff1[sz] = '\0';
+  printf(1, "XV6_TEST_OUTPUT : First Read returned : %d\n", sz);
+  printf(1, "XV6_TEST_OUTPUT : file content : %s\n", (char*)buff1);
+
+
+
+  // close file
+  rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file close suceeded\n");
+
+
+
+
+  // open the file again
+  fd = open(fileName, O_RDWR);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file open failed %d\n", fd);
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file open suceeded\n");
+
+
+
+  // mmap the file
+  int file_offset = 0;
+  int map_size = 50;
+  char *addr = (char *) mmap(0, map_size, PROT_WRITE, MAP_FILE, fd, file_offset);
+
+  if (addr<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : mmap suceeded\n");
+
+
+
+  // close file
+  rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file close suceeded\n");
+
+
+
+  // Read the content from the mmap-ed memory region
+  char buff2[256];
+  strcpy(buff2, addr);
+  printf(1, "XV6_TEST_OUTPUT : File content from mmap: %s\n", (char*)buff2);
+
+  int ret = strcmp(buff1, buff2);
+  printf(1, "XV6_TEST_OUTPUT : Return val of strcmp %d\n", ret);
+
+  if (ret == 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : File content and memory mapped content are Same.\n");
+  }
+  else
+  {
+    printf(1, "XV6_TEST_OUTPUT : File content and memory mapped content are different.\n");
+    exit();
+  }
+
+
+
+  // munmap
+  rc = munmap(addr, map_size);
+  if (rc < 0) 
+  {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : munmap suceeded\n");
+
+
+  exit();
+}
diff -ruN src/test_6.c src-finished/test_6.c
--- src/test_6.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_6.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,146 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+/* File Backed mmap test : testing msync */
+
+int PrintFileContents(char* fileName)
+{
+  int fd = open(fileName, O_RDONLY);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file open failed %d inside PrintFileContents function.\n", fd);
+    return 0;
+  }
+
+
+  char buff[256];
+  int sz = read(fd, buff, 50);
+  buff[sz] = '\0';
+  
+  printf(1, "XV6_TEST_OUTPUT : file content now : < %s >\n", (char*)buff);
+
+  // close file
+  int rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed inside PrintFileContents function.\n");
+    return 0;
+  }
+
+  return 1;
+}
+
+int
+main(int argc, char *argv[])
+{  
+  /*
+  Print the contents of file
+  Open an existing file.
+  mmap it.
+  write to the memory mapped region.
+  msync.
+  munmap.
+  Check file for newly written content.
+  close the file.
+  */
+  int rc;
+  char buff[256];
+  char fileName[50]="sample.txt";
+
+
+  // Print the file contents
+  if(!PrintFileContents(fileName))
+  {
+    printf(1, "XV6_TEST_OUTPUT : Printing file content failed.\n");
+    exit();
+  }
+
+
+  // Open file in Read-Write mode
+  int fd = open(fileName, O_RDWR);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file open failed %d\n", fd);
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file open suceeded\n");
+
+
+  // mmap the file
+  int file_offset = 0;
+  int map_size = 50;
+  char *addr = (char *) mmap(0, map_size, PROT_WRITE, MAP_FILE, fd, file_offset);
+
+  if (addr<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : mmap suceeded\n");
+
+
+
+  // Print the mmap-ed region.
+  strcpy(buff, addr);
+  printf(1, "XV6_TEST_OUTPUT : Before mysnc, content in mmap-ed region: %s\n", buff);
+
+
+
+  // write to the file-backed mmap memory region.
+  strcpy((char*)addr, "This is overwritten content.!");
+
+
+
+  // call msync
+  printf(1, "XV6_TEST_OUTPUT : msync return val : %d\n", msync(addr, map_size));
+
+
+
+  // Print the mmap-ed region.
+  strcpy(buff, addr);
+  printf(1, "XV6_TEST_OUTPUT : After mysnc, content in the mmap-ed region : %s\n", buff);
+
+
+
+  // Print the file contents
+  if(!PrintFileContents(fileName))
+  {
+    printf(1, "XV6_TEST_OUTPUT : Printing file content failed.\n");
+    exit();
+  }
+
+
+
+  //munmap
+  rc = munmap(addr, map_size);
+  if (rc < 0) 
+  {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : munmap suceeded\n");
+
+
+
+  // close file
+  rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file close suceeded\n");
+
+
+
+  exit();
+}
diff -ruN src/test_7.c src-finished/test_7.c
--- src/test_7.c	1970-01-01 00:00:00.000000000 +0000
+++ src-finished/test_7.c	2022-05-08 06:13:43.905873231 +0000
@@ -0,0 +1,131 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "mman.h"
+
+
+/* File Backed mmap test : testing file backed mmap with offset */
+int
+main(int argc, char *argv[])
+{  
+    /*
+   * Prepare a file which is filled with raw integer values. These
+   * integer values are their offsets in the file.
+   */
+  int rc;
+  char tmp_filename[26];
+  strcpy(tmp_filename, "test_file.txt");
+
+
+  // Create file
+  int fd = open(tmp_filename, O_WRONLY | O_CREATE);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file creation failed %d\n", fd);
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file creation suceeded\n");
+
+
+
+  // Write raw integer to the file
+  const int map_size = 0x10;
+  for (int i = 0; i < map_size * 2; i += sizeof(i))
+  {
+    uint written = write(fd, &i, sizeof(i));
+    printf(1, "XV6_TEST_OUTPUT : writing %d to file\n", i);
+
+    if(written != sizeof(i))
+    {
+      printf(1, "XV6_TEST_OUTPUT : file write failed\n");
+      exit();
+    }
+  }
+  printf(1, "XV6_TEST_OUTPUT : file write suceeded\n");
+
+
+
+  // close file
+  rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file close suceeded\n");
+
+
+
+  // Open file again
+  fd = open(tmp_filename, O_RDWR);
+  if(fd<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file open failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file open suceeded\n");
+
+
+
+  // mmap the file with a offset
+  /* A valid mmap call with an offset specified. */
+  int file_offset = 0x10;
+  char *addr = (char *) mmap(0, map_size, PROT_WRITE, MAP_FILE, fd, file_offset);
+
+  if (addr<=0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : mmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : mmap suceeded\n");
+
+
+
+  //Validate the contents of the file from the specified offset.
+  for (int i = 0; i < map_size; i += sizeof(i))
+  {
+    int expected = i + file_offset;
+    int actual = *(int *) (addr + i);
+
+    printf(1, "XV6_TEST_OUTPUT : Expected val : %d Actual val : %d\n",expected, actual);
+
+    if(actual != expected)
+    {
+      printf(1, "XV6_TEST_OUTPUT : file is Incorrectly mapped\n");
+      exit();
+    }
+  }
+  printf(1, "XV6_TEST_OUTPUT : file is correctly mapped\n");
+
+
+
+  //munmap
+  rc = munmap(addr, map_size);
+  if (rc < 0) 
+  {
+    printf(1, "XV6_TEST_OUTPUT : munmap failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : munmap suceeded\n");
+
+
+
+  // close file
+  rc = close(fd);
+  if(rc != 0)
+  {
+    printf(1, "XV6_TEST_OUTPUT : file close failed\n");
+    exit();
+  }
+  printf(1, "XV6_TEST_OUTPUT : file close suceeded\n");
+  
+  
+  exit();
+}
diff -ruN src/trap.c src-finished/trap.c
--- src/trap.c	2022-05-08 06:15:25.494748855 +0000
+++ src-finished/trap.c	2022-05-08 06:13:43.905873231 +0000
@@ -7,6 +7,10 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
+#include "mman.h"
+
+void pagefault_handler(struct trapframe *tf);
+extern pte_t *walkpgdir(pde_t *pgdir, const void *va, int alloc);
 
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
@@ -77,7 +81,9 @@
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
-
+  case T_PGFLT:
+    pagefault_handler(tf);
+    break;
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
@@ -110,3 +116,80 @@
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
 }
+
+void pagefault_handler(struct trapframe *tf) {
+  struct proc *curproc = myproc();
+  void *fault_addr = (void *) rcr2();
+  void *fault_page = (void *) PGROUNDDOWN((uint)fault_addr);
+
+  cprintf("============in pagefault_handler============\n" \
+          "pid %d %s: trap %d err %d on cpu %d " \
+          "eip 0x%x addr 0x%x\n", \
+          curproc->pid, curproc->name, tf->trapno, \
+          tf->err, cpuid(), tf->eip, fault_addr);
+
+  /*
+    31              15                             4               0
+    +---+--  --+---+-----+---+--  --+---+----+----+---+---+---+---+---+
+    |   Reserved   | SGX |   Reserved   | SS | PK | I | R | U | W | P |
+    +---+--  --+---+-----+---+--  --+---+----+----+---+---+---+---+---+
+    P	1 bit	: Present	When set, the page fault was caused by a page-protection violation. When not set, it was caused by a non-present page.
+    W	1 bit	: Write	When set, the page fault was caused by a write access. When not set, it was caused by a read access.
+    U	1 bit	: User	When set, the page fault was caused while CPL = 3. This does not necessarily mean that the page fault was a privilege violation.    
+  */
+  if ((tf->err & 0x1) != 0) {
+    /* Protection violation error. */
+    // cprintf("XV6_TEST_OUTPUT : try to write to nonwritable page\n");
+    curproc->killed = 1;
+    return;
+  }
+
+  /* Validate that the faulting address has been allocated by this process */
+  struct mmap_region *curr_region = curproc->mmap_regions;
+  while (curr_region != (struct mmap_region *) 0) {
+    /* Check the range of the region */
+    if (((uint) fault_addr >= curr_region->start_addr) &&
+         (uint) fault_addr < (curr_region->start_addr + curr_region->length)) {
+      // cprintf("XV6_TEST_OUTPUT : found mmap region\n");
+      break;
+    }
+
+    curr_region = curr_region->next_mmap_region;
+  }
+
+  /* Not a valid region so we kill the process */
+  if (curr_region == (struct mmap_region *) 0) {
+    curproc->killed = 1;
+    // cprintf("XV6_TEST_OUTPUT : not valid mmap region\n");
+    return;
+  }
+
+  /* Valid region so try to create a mapping in physical memory */
+  char *mem = kalloc();
+  if (mem == 0) {
+    /* No more memory available */
+    curproc->killed = 1;
+    // cprintf("XV6_TEST_OUTPUT : no more memory\n");
+    return;    
+  }
+  memset(mem, 0, PGSIZE);
+  if (mappages(curproc->pgdir, fault_page, PGSIZE, (uint) V2P(mem), curproc->mmap_regions->prot | PTE_U) < 0) {
+    kfree(mem);
+    curproc->killed = 1;
+    // cprintf("XV6_TEST_OUTPUT : unable to map regions\n");
+    return;
+  }
+
+  /* If map file, then copy the file into the page */
+  if (curr_region->flags == MAP_FILE) {
+    fileread((struct file *) curr_region->fd, fault_page, PGSIZE);
+
+    pde_t *pte = (pde_t *) 0;
+    if((pte = walkpgdir(curproc->pgdir, (void *)fault_page, 0)) == (pde_t *) 0) {
+      cprintf("XV6_TEST_OUTPUT : Failed to find allocated memory\n");
+      curproc->killed = 1;
+      return;
+    }
+    *pte &= ~(1U << PTE_D); // unset dirty bit    
+  }
+}
diff -ruN src/user.h src-finished/user.h
--- src/user.h	2022-05-08 06:15:25.498749031 +0000
+++ src-finished/user.h	2022-05-08 06:13:43.905873231 +0000
@@ -23,6 +23,11 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void* kmalloc(uint);
+void kmfree(void*);
+void* mmap(void*, uint, int, int, int, int);
+int munmap(void*, uint);
+int msync(void* start_addr, int length);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff -ruN src/usys.S src-finished/usys.S
--- src/usys.S	2022-05-08 06:15:25.490748680 +0000
+++ src-finished/usys.S	2022-05-08 06:13:43.905873231 +0000
@@ -29,3 +29,8 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(kmalloc)
+SYSCALL(kmfree)
+SYSCALL(mmap)
+SYSCALL(munmap)
+SYSCALL(msync)
diff -ruN src/vm.c src-finished/vm.c
--- src/vm.c	2022-05-08 06:15:25.482748329 +0000
+++ src-finished/vm.c	2022-05-08 06:13:43.905873231 +0000
@@ -32,7 +32,7 @@
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
-static pte_t *
+pte_t *
 walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
   pde_t *pde;
@@ -57,7 +57,7 @@
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-static int
+int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
   char *a, *last;
@@ -218,8 +218,8 @@
 
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+static int
+allocuvm_ex(pde_t *pgdir, uint oldsz, uint newsz)
 {
   char *mem;
   uint a;
@@ -247,6 +247,24 @@
   }
   return newsz;
 }
+int
+allocuvm_mmap(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  if(oldsz < MMAPBASE) {
+    panic("allocuvm_mmap: invalid oldsz");
+    return 0;
+  }
+  return allocuvm_ex(pgdir, oldsz, newsz);
+}
+int
+allocuvm_proc(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  if(newsz >= MMAPBASE) {
+    panic("allocuvm_proc: invalid newsz");
+    return 0;
+  }
+  return allocuvm_ex(pgdir, oldsz, newsz);
+}
 
 // Deallocate user pages to bring the process size from oldsz to
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
